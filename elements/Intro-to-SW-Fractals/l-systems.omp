; OM File Header - Saved 2023/05/03 18:14:15
; (7.01 :patc (om-make-point 154 202) (om-make-point 50 50) (om-make-point 500 400) "" 183 0 nil "2023/05/03 18:14:15")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"l-systems.omp\""))
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "l-systems" (quote ((let ((box (om-load-boxcall (quote lispfun) "ATOM" (quote atom) (quote ((om-load-inputfun (quote input-funbox) "OBJECT" "OBJECT" nil))) (om-make-point 67 132) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 116 181) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 190 246) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 91 434) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 507 171) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 186 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 103 54) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "variables" 4 (om-make-point 602 37) "" "variables" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 211 74) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "ZEROP" (quote zerop) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 63 308) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 70 252) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 142 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 167 169) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 253 431) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 320 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 389 177) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "STRING=" (quote string=) (quote ((om-load-inputfun (quote input-funbox) "STRING1" "STRING1" nil) (om-load-inputfun (quote input-funbox) "STRING2" "STRING2" nil))) (om-make-point 107 271) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINC-TO-STRING" (quote princ-to-string) (quote ((om-load-inputfun (quote input-funbox) "OBJECT" "OBJECT" nil))) (om-make-point 119 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINC-TO-STRING" (quote princ-to-string) (quote ((om-load-inputfun (quote input-funbox) "OBJECT" "OBJECT" nil))) (om-make-point 28 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 338 35) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NTH-RANDOM" (quote nth-random) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 274 244) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 213 153) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 260 74) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 157 400) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 188 326) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 220 493) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 136 496) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((11 1 0 1 nil 0) (9 0 1 0 nil 0) (10 0 2 0 nil 0) (8 1 2 1 nil 0) (5 0 3 0 nil 0) (4 0 3 1 nil 0) (8 0 4 0 nil 0) (10 0 5 0 nil 0) (1 0 7 0 nil 0) (9 0 8 0 nil 0) (6 0 9 0 nil 0) (12 0 11 0 nil 0) (3 0 12 0 nil 0) (7 0 12 1 nil 0) (0 0 13 0 nil 0) (11 0 14 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 173 330) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 72 109) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 199 43) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 211 413) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 111 413) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (0 0 2 0 nil 0) (5 0 2 1 nil 0) (3 0 2 2 nil 0) (5 0 3 0 nil 0) (6 0 3 1 nil 0) (2 0 4 0 nil 0) (7 0 5 0 nil 0) (4 1 8 0 nil 0) (4 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 156 297) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "last-n" 3 (om-make-point 560 37) "def = 1 (don't change)" "last-n" 1 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 325 320) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LAST-N" (quote last-n) (quote ((om-load-inputfun (quote input-funbox) "a list" "OBJ" nil) (om-load-inputfun (quote input-funbox) "number of elements" "NTH" 0))) (om-make-point 144 56) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 238 184) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 181 237) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 1 (om-make-point 258 34) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 99 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 160 143) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "STRING=" (quote string=) (quote ((om-load-inputfun (quote input-funbox) "STRING1" "STRING1" nil) (om-load-inputfun (quote input-funbox) "STRING2" "STRING2" nil))) (om-make-point 95 283) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINC-TO-STRING" (quote princ-to-string) (quote ((om-load-inputfun (quote input-funbox) "OBJECT" "OBJECT" nil))) (om-make-point 118 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINC-TO-STRING" (quote princ-to-string) (quote ((om-load-inputfun (quote input-funbox) "OBJECT" "OBJECT" nil))) (om-make-point 24 229) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 272 529) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (let ((box (om-load-boxcall (quote genfun) "LIST-ELEMENTS" (quote list-elements) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 209 177) nil nil nil nil 2))) (setf (numouts box) 2) box))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 227 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 228 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 154 352) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 188 480) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 229 591) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 129 591) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (4 0 1 0 nil 0) (9 0 2 0 nil 0) (8 1 3 1 nil 0) (5 0 4 0 nil 0) (6 0 5 0 nil 0) (0 0 7 0 nil 0) (4 1 7 1 nil 0) (7 0 8 0 nil 0) (3 0 10 0 nil 0) (8 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 224 307) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 124 307) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (4 0 2 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "omloop 2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "n-times" 2 (om-make-point 454 39) "" "n-times" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "rules" 1 (om-make-point 366 38) "" "rules" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 123 486) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "l-systems" (quote ("elements" "Intro-to-SW-Fractals" "l-systems")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "rules" nil) (om-load-inputfun (quote input-funbox) "" "n-times" nil) (om-load-inputfun (quote input-funbox) "def = 1 (don't change)" "last-n" 1) (om-load-inputfun (quote input-funbox) "" "variables" nil))) (om-make-point 281 397) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 28 554) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 22 45) "" "input" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (0 0 1 0 nil 0) (13 0 1 1 nil 0) (8 0 1 2 nil 0) (10 0 2 0 nil 0) (15 0 3 0 nil 0) (15 0 4 0 nil 0) (1 0 5 0 nil 0) (20 0 6 0 nil 0) (13 0 8 0 nil 0) (7 0 8 1 nil 0) (20 0 9 0 nil 0) (2 0 9 1 nil 0) (14 0 10 0 nil 0) (10 0 12 0 nil 0) (6 0 13 0 nil 0) (11 0 13 1 nil 0) (5 0 14 0 nil 0) (16 0 14 1 nil 0) (3 0 17 0 nil 0) (20 0 17 1 nil 0) (18 0 17 2 nil 0) (9 0 18 0 nil 0) (16 0 18 1 nil 0) (4 0 18 2 nil 0) (12 0 18 3 nil 0) (7 0 18 4 ((om-make-point 628 94) (om-make-point 628 216) (om-make-point 558 339) (om-make-point 331 397)) 0) (17 0 19 0 nil 0))) nil 7.01))
