; OM File Header - Saved 2023/02/06 12:43:50
; (7.01 :patc (om-make-point 172 60) (om-make-point 1697 25) (om-make-point 1349 974) "" 183 0 nil "2023/02/06 12:43:06")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "004-intro-to-multiplication" (quote ((let ((box (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 458 625) (om-make-point 254 118) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 8300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (7600 8600 6700 7700 7800 8800))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1771 261) (om-make-point 729 308) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 3" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 549 546) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 764 546) (om-make-point 434 320) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 8300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (7600 8600 6700 7700 7800 8800))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 8900 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 7900 8700 9000 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 7900 6700 7000 7800 8100))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000) (1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000) (1000 1000 1000 1000) (1000 1000) (1000) (1000 1000 1000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 8600 6500 7400 7600) (6200 7100 7300 8200 8400 7900 8100 5900 6800 7000) (6900 7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0)) ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0)) ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)) ((0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1682 544) (om-make-point 609 484) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g) (quote g) (quote g)) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "partitions->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 675 431) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 386 433) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 198 210) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list-of-midics" 0 (om-make-point 5 45) "" "grouped-list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 433 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 333 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 1 0 nil 0) (1 0 2 1 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "partitions->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb-total" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chords" nil) (om-load-inputfun (quote input-funbox) "" "interval-lists" nil))) (om-make-point 625 310) nil nil nil (list (let ((box (om-load-boxwithed1 (quote box-with-win) "iterate-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-members" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 146 235) (om-make-point 104 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 264 464) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-DUPLICATES" (quote remove-duplicates) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 249 387) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 113 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 205 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "Tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 340 62) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-members" 0 (om-make-point 5 45) "" "chord-members" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 316 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 216 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (6 0 3 0 nil 0) (3 0 4 0 nil 0) (5 0 4 1 nil 0) (0 1 7 0 nil 0) (0 0 8 0 nil 0))) 1 "iterate-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 175 439) (om-make-point 110 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 274 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-lists" 1 (om-make-point 396 44) "" "interval-lists" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 37 108) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 275 539) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "Tn-comb-total" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-DUPLICATES 2" (quote remove-duplicates) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 267 660) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 232 550) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 247 455) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "Tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 347 372) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 275 372) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 344 227) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 380 305) (om-make-point 37 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 137 233) (om-make-point 33 39) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 101 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 40 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 182 392) (om-make-point 141 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 513) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 328 143) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 269 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 274 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 340 626) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 158 614) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 4 0 nil 0) (8 0 4 1 nil 0) (0 0 4 2 nil 0) (4 0 5 0 nil 0) (10 0 7 0 nil 0) (6 0 7 1 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0) (5 1 11 0 nil 0) (5 0 12 0 nil 0))) 1 "return-internal-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals-beta" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 56 229) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 314 333) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 209 149) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 152 213) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 230 274) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 89 117) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 368 426) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 268 426) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (5 0 2 0 nil 0) (1 0 2 1 nil 0) (2 0 3 0 nil 0) (4 0 5 0 nil 0) (0 1 6 0 nil 0) (0 0 7 0 nil 0))) 1 "return-internal-intervals-beta" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 129 71) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (3 0 2 1 nil 0) (4 0 3 0 nil 0) (12 1 4 0 nil 0) (10 0 4 1 nil 0) (6 0 5 0 nil 0) (7 0 6 0 nil 0) (9 0 7 0 nil 0) (8 0 7 1 nil 0) (10 0 8 0 nil 0) (12 1 9 0 nil 0) (12 1 10 0 nil 0) (12 1 11 0 nil 0))) nil 7.01))
