; OM File Header - Saved 2023/02/06 12:43:50
; (7.01 :patc (om-make-point 172 110) (om-make-point 1510 25) (om-make-point 1487 944) "" 183 0 nil "2023/02/06 12:43:06")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "006-domain-I" (quote ((let ((box (om-load-editor-box1 "MULTI-SEQ 2" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 982 323) (om-make-point 287 209) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)) ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)) ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)) ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1555 141) (om-make-point 1067 583) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g) (quote g) (quote g)) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "multiplication" (om-load-patch-abs1 "multiplication" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 375 423) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb-final-unique-pc" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chords" nil) (om-load-inputfun (quote input-funbox) "" "interval-lists" nil))) (om-make-point 181 234) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 356 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 375 216) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "iterate-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-members" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 146 235) (om-make-point 104 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 376 376) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 395 236) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 264 464) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 113 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 205 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "Tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 340 62) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-members" 0 (om-make-point 5 45) "" "chord-members" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 316 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 216 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (0 0 2 0 nil 0) (5 0 3 0 nil 0) (7 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (2 1 8 0 nil 0) (2 0 9 0 nil 0))) 1 "iterate-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 175 439) (om-make-point 110 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 274 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-lists" 1 (om-make-point 396 44) "" "interval-lists" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 37 108) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 275 539) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (6 0 2 0 nil 0) (4 0 2 1 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "Tn-comb-final-unique-pc" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "partitions->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list-of-midics" nil))) (om-make-point 279 330) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 503 167) (om-make-point 34 30) (list 50) "(50)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 413 167) (om-make-point 58 30) (list 4000) "(4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 331 164) (om-make-point 69 30) (list 0 4000) "(0 4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 386 433) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 198 210) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list-of-midics" 0 (om-make-point 5 45) "" "grouped-list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 433 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 333 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (2 0 5 2 nil 0) (1 0 5 3 nil 0) (0 0 5 4 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "partitions->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 115 107) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 380 305) (om-make-point 37 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 137 233) (om-make-point 33 39) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 101 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 40 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 182 392) (om-make-point 141 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 513) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 328 143) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 269 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 274 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 340 626) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 158 614) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 4 0 nil 0) (8 0 4 1 nil 0) (0 0 4 2 nil 0) (4 0 5 0 nil 0) (10 0 7 0 nil 0) (6 0 7 1 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0) (5 1 11 0 nil 0) (5 0 12 0 nil 0))) 1 "return-internal-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq" 0 (om-make-point 5 45) "" "chord-seq" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 1 0 nil 0) (3 0 1 1 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 824 537)) (quote ((om-load-inputfun (quote input-funbox) "" "chord-seq" nil))) (om-make-point 921 206) nil (list (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))) nil "multiplication"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 559 474) (om-make-point 287 209) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)) ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)) ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)) ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1555 141) (om-make-point 1067 583) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g) (quote g) (quote g)) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "partitions->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list-of-midics" nil))) (om-make-point 760 369) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 503 167) (om-make-point 34 30) (list 50) "(50)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 413 167) (om-make-point 58 30) (list 4000) "(4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 331 164) (om-make-point 69 30) (list 0 4000) "(0 4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 386 433) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 198 210) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list-of-midics" 0 (om-make-point 5 45) "" "grouped-list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 433 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 333 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (2 0 5 2 nil 0) (1 0 5 3 nil 0) (0 0 5 4 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "partitions->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb-final-unique-pc" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chords" nil) (om-load-inputfun (quote input-funbox) "" "interval-lists" nil))) (om-make-point 665 269) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 356 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 375 216) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "iterate-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-members" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 146 235) (om-make-point 104 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 376 376) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 395 236) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 264 464) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 113 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 205 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "Tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 340 62) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-members" 0 (om-make-point 5 45) "" "chord-members" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 316 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 216 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (0 0 2 0 nil 0) (5 0 3 0 nil 0) (7 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (2 1 8 0 nil 0) (2 0 9 0 nil 0))) 1 "iterate-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 175 439) (om-make-point 110 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 274 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-lists" 1 (om-make-point 396 44) "" "interval-lists" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 37 108) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 275 539) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (6 0 2 0 nil 0) (4 0 2 1 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "Tn-comb-final-unique-pc" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 631 59) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 520 203) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 380 305) (om-make-point 37 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 137 233) (om-make-point 33 39) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 101 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 40 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 182 392) (om-make-point 141 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 513) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 328 143) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 269 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 274 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 340 626) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 158 614) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 4 0 nil 0) (8 0 4 1 nil 0) (0 0 4 2 nil 0) (4 0 5 0 nil 0) (10 0 7 0 nil 0) (6 0 7 1 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0) (5 1 11 0 nil 0) (5 0 12 0 nil 0))) 1 "return-internal-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 208 486) (om-make-point 169 118) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200 7200 7300 7000 8000 5900 6900)) :ldur (quote (1000 1000 1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100 100 100)) :loffset (quote (0 0 0 0 0 0 0)) :lchan (quote (1 1 1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 0 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP 2" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 171 335) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 1973 279) (om-make-point 557 437)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 238 191) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 97 216) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 101 49) (om-make-point 254 118) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 8300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (7600 8600 6700 7700 7800 8800))) :lonset (quote (0 1000 2000 3000 4000 5000)) :ldur (quote ((1000 1000 1000) (1000 1000 1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1771 261) (om-make-point 729 308) 0 1000 nil 1 (quote :midi-player) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 1 nil 0) (5 1 1 0 nil 0) (3 0 2 1 nil 0) (4 0 3 0 nil 0) (5 1 4 0 nil 0) (6 0 4 1 nil 0) (5 1 6 0 nil 0) (8 0 7 1 nil 0) (10 0 8 0 nil 0) (9 0 8 1 nil 0) (11 1 10 0 nil 0))) nil 7.01))
