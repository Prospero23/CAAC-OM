; OM File Header - Saved 2023/02/08 17:13:32
; (7.01 :patc (om-make-point 496 10) (om-make-point 2016 89) (om-make-point 1157 948) "" 183 0 nil nil)
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "004-Rot-PR-IRI" (quote ((let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 153 651) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINT" (quote print) (quote ((om-load-inputfun (quote input-funbox) "SOMETHING" "SOMETHING" nil))) (om-make-point 73 652) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all-rotations 2" (om-load-patch-abs1 "all-rotations" (quote ((let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "give-all-list-rotations" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 39 343) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 94 119) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 124 214) (om-make-point 71 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 211 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list-ind" 1 (om-make-point 262 51) "" "list-ind" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 181 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 81 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "give-all-list-rotations" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 113 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 130 88) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 173 167) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 209 123) (om-make-point 17 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 261 452) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "returns-all-rotations" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 1 nil 0) (0 0 3 0 nil 0) (3 0 4 0 nil 0) (5 0 4 1 nil 0) (1 0 6 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 248 448) nil (list (list (list 6900 7100 7000 7300 7400 7900 7500) (list 7100 7000 7300 7400 7900 7500 6900) (list 7000 7300 7400 7900 7500 6900 7100) (list 7300 7400 7900 7500 6900 7100 7000) (list 7400 7900 7500 6900 7100 7000 7300) (list 7900 7500 6900 7100 7000 7300 7400) (list 7500 6900 7100 7000 7300 7400 7900))) nil "all-rotations"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 414 676) (om-make-point 254 227) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6900) (7100) (7000) (7300) (7400) (7900) (7500))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7100) (7000) (7300) (7400) (7900) (7500) (6900))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7000) (7300) (7400) (7900) (7500) (6900) (7100))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7300) (7400) (7900) (7500) (6900) (7100) (7000))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7400) (7900) (7500) (6900) (7100) (7000) (7300))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7900) (7500) (6900) (7100) (7000) (7300) (7400))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500) (6900) (7100) (7000) (7300) (7400) (7900))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1477 233) (om-make-point 779 419) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g) (quote g) (quote g) (quote g) (quote g)) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 421 522) (om-make-point 62 30) (list 0 500) "(0 500)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "mclist->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "mc->chord-seq" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 365 557) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 271 310) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 218 218) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "offsets" 1 (om-make-point 222 48) "" "offsets" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 123 136) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "mc->chord-seq" 0 (om-make-point 5 45) "" "mc->chord-seq" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 325 370) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 225 370) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 0 1 1 nil 0) (2 0 1 2 nil 0) (4 0 3 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "mclist->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "T-Rot" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 874 347) (om-make-point 130 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 315 126) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 229 274) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "T" (om-load-patch-abs1 "T" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 153 254) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 113 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 190 48) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 159 164) (om-make-point 98 67) (list (list 6900 7100 7000 7300 7400 7900 7500)) nil "T"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "All-rotations" 1 (om-make-point 253 47) "" "All-rotations" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 295 368) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 195 368) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (0 0 2 1 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "T-Rot" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 133 497) (om-make-point 62 30) (list 0 500) "(0 500)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 91 543) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6900) (7100) (7000) (7300) (7400) (7900) (7500))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 25) (om-make-point 370 280) 0 1000 nil 101/50 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 100 328) (om-make-point 20 32) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 9 291) (om-make-point 20 31) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 126 357) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 27 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 81 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 263 66) (om-make-point 62 30) (list 0 500) "(0 500)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 59 42) (om-make-point 60 90) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700 6900 6800 7100 7200 7700 7300)) :ldur (quote (1000 1000 1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100 100 100)) :loffset (quote (0 0 0 0 0 0 0)) :lchan (quote (1 1 1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 0 0 (om-make-point 1554 145) (om-make-point 514 302) 3 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 209 149) (om-make-point 158 93) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6700) (6900) (6800) (7100) (7200) (7700) (7300))) :lonset (quote (0 500 1000 1500 2000 2500 3000 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 1595 229) (om-make-point 778 516) 0 1000 nil 3 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "RI" (om-load-patch-abs1 "RI" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 146 235) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 159 39) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "I" (om-load-patch-abs1 "I" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 214 292) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 184 41) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 303 138) (om-make-point 22 30) -1 "-1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 207 140) (om-make-point 49 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 136 203) (om-make-point 99 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (1 0 4 0 nil 0) (3 0 4 1 nil 0) (2 0 5 0 nil 0) (4 0 5 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 77 133) (om-make-point 83 67) nil nil "I"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 751 91) nil nil nil "RI"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "I" (om-load-patch-abs1 "I" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 214 292) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 184 41) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 303 138) (om-make-point 22 30) -1 "-1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 207 140) (om-make-point 49 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 136 203) (om-make-point 99 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (1 0 4 0 nil 0) (3 0 4 1 nil 0) (2 0 5 0 nil 0) (4 0 5 1 nil 0))) 7.01 nil "" (om-make-point 236 132) (om-make-point 579 453)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 690 101) nil nil nil "I"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "R" (om-load-patch-abs1 "R" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 226 268) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 165 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 168 50) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "T" (om-load-patch-abs1 "T" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 153 254) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 113 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 190 48) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 93 129) nil nil nil "T"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (3 0 4 0 nil 0) (2 0 4 1 nil 0))) 7.01 nil "" (om-make-point 1775 542) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 867 128) nil nil nil "R"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "T" (om-load-patch-abs1 "T" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 153 254) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 113 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-series" 1 (om-make-point 190 48) "" "interval-series" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "starting-note" 0 (om-make-point 5 45) "" "starting-note" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0))) 7.01 nil "" (om-make-point 1530 267) (om-make-point 485 466)) (quote ((om-load-inputfun (quote input-funbox) "" "starting-note" nil) (om-load-inputfun (quote input-funbox) "" "interval-series" nil))) (om-make-point 74 417) nil (list (list 6900 7100 7000 7300 7400 7900 7500)) nil "T"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all-rotations" (om-load-patch-abs1 "all-rotations" (quote ((let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "give-all-list-rotations" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 39 343) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 94 119) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 124 214) (om-make-point 71 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 211 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list-ind" 1 (om-make-point 262 51) "" "list-ind" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 181 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 81 319) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "give-all-list-rotations" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 113 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 130 88) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 173 167) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 209 123) (om-make-point 17 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 261 452) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "returns-all-rotations" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 1 nil 0) (0 0 3 0 nil 0) (3 0 4 0 nil 0) (5 0 4 1 nil 0) (1 0 6 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 119 270) nil (list (list (list 200 -100 300 100 500 -400) (list -100 300 100 500 -400 200) (list 300 100 500 -400 200 -100) (list 100 500 -400 200 -100 300) (list 500 -400 200 -100 300 100) (list -400 200 -100 300 100 500))) nil "all-rotations"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (8 1 1 0 nil 0) (20 0 2 0 nil 0) (5 0 3 1 nil 0) (2 0 5 0 nil 0) (4 0 5 1 nil 0) (20 0 8 1 nil 0) (7 0 8 2 nil 0) (9 0 11 0 nil 0) (21 0 11 1 nil 0) (10 0 12 0 nil 0) (15 1 12 1 nil 0) (15 1 13 0 nil 0) (15 1 16 1 nil 0) (14 0 16 2 nil 0) (12 0 20 0 nil 0) (11 0 20 1 nil 0) (13 0 21 0 nil 0))) nil 7.01))
