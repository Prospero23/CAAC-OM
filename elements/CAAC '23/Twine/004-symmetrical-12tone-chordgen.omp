; OM File Header - Saved 2023/04/03 11:56:33
; (7.01 :patc (om-make-point 442 10) (om-make-point 338 25) (om-make-point 942 747) "" 183 0 nil nil)
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "004-symmetrical-12tone-chordgen" (quote ((let ((box (om-load-boxcomment "comment 2" (om-make-point 502 30) (quote "You may choose a random ordering or preferrably order the hexachord yourself.") nil (om-make-point 318 287) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 400 45) (quote "This patch generates inversionally symmetrical 12-tone chords $out of hexachords that have inversional combinatoriality.") nil (om-make-point 355 142) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 625 423) (om-make-point 34 30) (list 30) "(30)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 543 423) (om-make-point 48 30) (list 4000) "(4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 453 421) (om-make-point 59 30) (list 0 4000) "(0 4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 381 487) (om-make-point 257 178) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((2700 3000 3600 4000 4300 4500 5600 5800 6100 6500 7100 7400) (2500 2600 3300 3400 4100 4700 5400 6000 6700 6800 7500 7600) (2600 2800 3200 4200 4800 4900 5800 5900 6500 7500 7900 8100) (2500 2600 3000 3900 4400 4500 5200 5300 5800 6700 7100 7200) (2700 3000 4100 4600 4700 4800 5500 5600 5700 6200 7300 7600) (2500 2600 3400 4500 5100 5300 6400 6600 7200 8300 9100 9200) (3500 4600 4800 5200 6100 6500 7400 7800 8700 9100 9300 10400))) :lonset (quote (0 4000 8000 12000 16000 20000 24000 28000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30) (30 30 30 30 30 30 30 30 30 30 30 30))) :loffset (quote ((0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote ggff) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 1078 520) (om-make-point 1721 376) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 363 335) (om-make-point 32 30) -3 "-3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "symmetrical-12tone-chordgen" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "pc-set" nil) (om-load-inputfun (quote input-funbox) "" "octave-displacement" nil))) (om-make-point 242 389) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 604 473) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 372 689) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "pc->midic" (om-load-patch-abs1 "pc->midic" (quote ((let ((box (om-load-boxcall (quote genfun) "OM+ 2" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 129 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 258 128) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 225 177) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 12 160) (om-make-point 38 30) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 86 95) (om-make-point 31 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 62 126) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 40 191) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 148 339) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "midic" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "octave-displacement" 1 (om-make-point 147 45) "" "octave-displacement" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pc" 0 (om-make-point 5 45) "" "pc" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 0 1 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (9 0 5 0 nil 0) (4 0 5 1 nil 0) (3 0 6 0 nil 0) (5 0 6 1 nil 0) (0 0 7 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "pc" nil) (om-load-inputfun (quote input-funbox) "" "octave-displacement" nil))) (om-make-point 94 727) nil (list 3100) nil "pc->midic"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 70 653) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 216 606) (om-make-point 25 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 262 567) (om-make-point 31 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "opci" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 144 568) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 155 350) (om-make-point 24 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 119 396) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 63 346) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 18 121) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 289 370) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 240 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 160 171) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 4 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 352 482) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 212 483) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 1 0 nil 0) (0 0 1 1 nil 0) (5 0 2 0 nil 0) (7 0 2 1 nil 0) (8 0 3 0 nil 0) (1 0 4 0 nil 0) (6 0 5 0 nil 0) (8 0 5 1 nil 0) (7 0 6 0 nil 0) (3 0 7 0 nil 0) (4 1 9 0 nil 0) (4 0 10 0 nil 0))) 1 "opci" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 53 488) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 270 497) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "INV" (quote inv) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "SET" (list 0 1 2 7)))) (om-make-point 144 300) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 271 347) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 226 263) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "mod12" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list-of-integers" nil))) (om-make-point 313 417) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 198) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 224 124) (om-make-point 24 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 175 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 92 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list-of-integers" 0 (om-make-point 5 45) "" "list-of-integers" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (4 0 3 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "mod12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "Tlevel-I-Comb" (om-load-patch-abs1 "Tlevel-I-Comb" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 484 639) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "Tlevel-I-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tlevel-I-comb" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "index-vector" nil))) (om-make-point 423 566) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 359 700) (om-make-point 23 30) nil "nil" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 400 690) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 283 350) (om-make-point 30 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 249 384) (om-make-point 20 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 295 402) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 341 585) (om-make-point 93 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 149 278) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 108 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 225 327) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 75 224) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 175 158) (om-make-point 17 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 130 179) (om-make-point 21 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "index-vector" 0 (om-make-point 11 51) "" "index-vector" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 461 709) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 301 717) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((0 0 1 0 nil 0) (5 1 1 1 nil 0) (8 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (6 0 4 1 nil 0) (4 0 5 0 nil 0) (9 0 6 0 nil 0) (12 0 7 0 nil 0) (6 0 8 0 nil 0) (12 0 8 1 nil 0) (11 0 9 1 nil 0) (7 0 11 0 nil 0) (10 0 11 1 nil 0) (1 0 13 0 nil 0) (5 0 14 0 nil 0))) 1 "tlevel-i-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "index-vector" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "pc-set" nil))) (om-make-point 355 464) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 504 729) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LAST" (quote last) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 442 700) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 282 623) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 348 719) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 12" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 642 360) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 11" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 515 360) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 10" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 399 362) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 9" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 293 351) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 8" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 363) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 7" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 49 357) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 6" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 689 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 5" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 571 109) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 4" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 450 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 3" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 339 133) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 189 138) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 12" (quote list) (quote nil) (om-make-point 719 398) (om-make-point 34 30) 11 "11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 12" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 704 480) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 12" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 692 440) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 11" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 567 479) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 582 397) (om-make-point 34 30) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 11" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 555 439) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 10" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 446 471) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 461 389) (om-make-point 27 30) 9 "9" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 10" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 434 431) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 9" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 346 467) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 9" (quote list) (quote nil) (om-make-point 361 385) (om-make-point 27 30) 8 "8" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 9" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 334 427) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 8" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 231 472) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 8" (quote list) (quote nil) (om-make-point 246 390) (om-make-point 27 30) 7 "7" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 8" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 219 432) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 7" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 115 470) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 130 388) (om-make-point 27 30) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 7" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 103 430) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 6" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 743 227) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 758 145) (om-make-point 27 30) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 6" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 731 187) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 5" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 621 223) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 636 141) (om-make-point 27 30) 4 "4" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 5" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 609 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 4" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 504 227) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 519 145) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 4" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 492 187) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 3" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 392 228) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 407 146) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 3" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 380 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count 2" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 242 231) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 257 149) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 230 191) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "count" (quote counter) (quote ((om-load-inputfun (quote input-funbox) "things to count" "SOMETHING" nil))) (om-make-point 123 236) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 138 154) (om-make-point 30 32) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 111 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 63 124) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pc-set" 0 (om-make-point 5 45) "" "pc-set" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 468 804) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 221 800) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 1 1 0 nil 0) (48 0 2 0 nil 0) (45 0 2 1 nil 0) (42 0 2 2 nil 0) (39 0 2 3 nil 0) (36 0 2 4 nil 0) (33 0 2 5 nil 0) (30 0 2 6 nil 0) (27 0 2 7 nil 0) (24 0 2 8 nil 0) (21 0 2 9 nil 0) (18 0 2 10 nil 0) (16 0 2 11 nil 0) (2 0 3 0 nil 0) (52 0 4 0 nil 0) (52 0 5 0 nil 0) (52 0 6 0 nil 0) (52 0 7 0 nil 0) (52 0 8 0 nil 0) (52 0 9 0 nil 0) (52 0 10 0 nil 0) (52 0 11 0 nil 0) (52 0 12 0 nil 0) (52 0 13 0 nil 0) (52 0 14 0 nil 0) (17 0 16 0 nil 0) (4 0 17 0 nil 0) (15 0 17 1 nil 0) (20 0 18 0 nil 0) (5 0 20 0 nil 0) (19 0 20 1 nil 0) (23 0 21 0 nil 0) (6 0 23 0 nil 0) (22 0 23 1 nil 0) (26 0 24 0 nil 0) (7 0 26 0 nil 0) (25 0 26 1 nil 0) (29 0 27 0 nil 0) (8 0 29 0 nil 0) (28 0 29 1 nil 0) (32 0 30 0 nil 0) (9 0 32 0 nil 0) (31 0 32 1 nil 0) (35 0 33 0 nil 0) (10 0 35 0 nil 0) (34 0 35 1 nil 0) (38 0 36 0 nil 0) (11 0 38 0 nil 0) (37 0 38 1 nil 0) (41 0 39 0 nil 0) (12 0 41 0 nil 0) (40 0 41 1 nil 0) (44 0 42 0 nil 0) (13 0 44 0 nil 0) (43 0 44 1 nil 0) (47 0 45 0 nil 0) (14 0 47 0 nil 0) (46 0 47 1 nil 0) (50 0 48 0 nil 0) (51 0 50 0 nil 0) (49 0 50 1 nil 0) (52 0 51 0 nil 0) (0 0 53 0 nil 0) (3 0 54 0 nil 0))) 1 "index-vector" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "index-sums" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 324 377) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 304 338) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 281 242) (om-make-point 24 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MOD" (quote mod) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "Y" "Y" nil))) (om-make-point 241 295) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 177 291) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 198 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 113 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 76 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 374 426) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 274 426) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (5 0 3 0 nil 0) (4 0 3 1 nil 0) (6 0 4 0 nil 0) (6 0 5 0 nil 0) (7 0 6 0 nil 0) (0 1 8 0 nil 0) (0 0 9 0 nil 0))) 1 "index-sums" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 308 298) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 334 255) (om-make-point 40 23) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "find-all-pairs" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 207 233) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 284 416) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pairing" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "nth-elem" nil) (om-load-inputfun (quote input-funbox) "" "cdr-of-list" nil))) (om-make-point 231 351) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 268 270) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 128 236) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 232 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "cdr-of-list" 1 (om-make-point 260 52) "" "cdr-of-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "nth-elem" 0 (om-make-point 5 45) "" "nth-elem" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 382 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 282 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "pairing" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "onlist" (quote onlistloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 285 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 123 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 62 155) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 444 546) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 124 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0) (5 0 2 0 nil 0) (4 0 3 0 nil 0) (5 0 4 0 nil 0) (0 1 6 0 nil 0) (0 0 7 0 nil 0))) 1 "find-all-pairs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pc-set" 0 (om-make-point 171 139) "" "pc-set" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 3 0 nil 0) (6 0 4 0 nil 0) (5 0 4 1 nil 0) (7 0 6 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "pc-set" nil))) (om-make-point 141 167) nil (list (list 11)) nil "Tlevel-I-Comb"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 51 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "octave-displacement" 1 (om-make-point 120 655) "" "octave-displacement" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pc-set" 0 (om-make-point 5 45) "" "pc-set" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 703 670) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 548 661) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 1 1 nil 0) (3 0 2 0 nil 0) (15 0 2 1 nil 0) (6 0 3 0 nil 0) (6 0 4 0 nil 0) (5 0 4 1 nil 0) (7 0 6 0 nil 0) (14 0 7 0 nil 0) (8 0 7 1 nil 0) (12 0 8 0 nil 0) (14 0 9 1 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0) (13 0 11 0 nil 0) (10 0 12 0 nil 0) (14 0 13 0 nil 0) (16 0 14 0 nil 0) (0 1 17 0 nil 0) (0 0 18 0 nil 0))) 1 "symmetrical-12tone-chordgen" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "permut-random" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list-of-pcs" nil))) (om-make-point 221 298) nil nil "x" (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 217 223) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PERMUT-RANDOM" (quote permut-random) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 185 126) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 104 91) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list-of-pcs" 0 (om-make-point 5 45) "" "list-of-pcs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 271 307) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 171 307) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "permut-random" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 225 139) (om-make-point 99 30) (list 0 1 2 3 5 8 13) "(0 1 2 3 5 8 13)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 168 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "I-combinatorial-hex" (om-load-patch-abs1 "I-combinatorial-hex" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 85 463) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "I-comb-hex" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 16 30) (quote "") "" (om-make-point 279 115) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pcs-fn-comp" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "pcset" nil) (om-load-inputfun (quote input-funbox) "" "fn" nil) (om-load-inputfun (quote input-funbox) "" "compl" nil))) (om-make-point 260 450) (om-make-point 220 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist 3" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 511 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 468 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "compl" 2 (om-make-point 501 46) "" "compl" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 71 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 273 304) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 160 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 325 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 47 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "fn" 1 (om-make-point 277 45) "" "fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pcset" 0 (om-make-point 5 45) "" "pcset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 326 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 226 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (7 0 3 0 nil 0) (5 0 4 0 nil 0) (3 0 5 0 nil 0) (6 0 5 1 nil 0) (1 0 5 2 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (4 1 10 0 nil 0) (4 0 11 0 nil 0))) 1 "pcs-fn-comp" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "get-complement" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 370 341) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 279 251) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "COMP" (quote comp) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FROM" 3) (om-load-inputfun (quote input-funbox) "" "TO" 13) (om-load-inputfun (quote input-funbox) "" "LIST" (list 0 1 2 7)))) (om-make-point 161 156) (om-make-point 183 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 72 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 385 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 285 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 3 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "get-complement" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "PC-sets" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "hexachords" nil))) (om-make-point 193 341) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "PC-SET" (quote pc-set) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "vector" (quote :vector)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FN-NAME" (quote |6-Z10|)))) (om-make-point 219 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 261 200) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 124 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "hexachords" 0 (om-make-point 5 45) "" "hexachords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 307 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "pc-sets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 387 582) (om-make-point 261 245) (load-buffer-textfile (quote ("((0 1 3 4 6 9) 6-27 (2 5 7 8 10 11))" "((0 1 2 4 5 8) 6-15 (3 6 7 9 10 11))" "((0 1 2 4 6 8) 6-22 (3 5 7 9 10 11))" "((0 1 2 5 7 8) 6-18 (3 4 6 9 10 11))" "((0 1 2 6 7 8) 6-7 (3 4 5 9 10 11))" "((0 1 2 5 7 8) 6-18 (3 4 6 9 10 11))" "((0 1 4 5 6 8) 6-16 (2 3 7 9 10 11))" "((0 2 3 4 6 8) 6-21 (1 5 7 9 10 11))" "((0 1 4 5 6 8) 6-16 (2 3 7 9 10 11))" "((0 2 3 4 6 8) 6-21 (1 5 7 9 10 11))" "((0 1 2 4 6 8) 6-22 (3 5 7 9 10 11))" "((0 1 2 4 5 8) 6-15 (3 6 7 9 10 11))" "((0 1 2 3 5 7) 6-9 (4 6 8 9 10 11))" "((0 1 2 3 6 7) 6-5 (4 5 8 9 10 11))" "((0 2 3 4 5 7) 6-8 (1 6 8 9 10 11))" "((0 1 2 3 5 7) 6-9 (4 6 8 9 10 11))" "((0 1 2 3 4 6) 6-2 (5 7 8 9 10 11))" "((0 1 2 3 4 5) 6-1 (6 7 8 9 10 11))" "" "")) (quote textfile) "supersede" "list") "x" nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-ITER" (quote remove-iter) (quote ((om-load-inputfun (quote input-funbox) "sequence" "SEQUENCE" (list 1 2)))) (om-make-point 243 289) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "ForteN" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "hexachords" nil))) (om-make-point 91 231) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 261 200) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 124 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-FORM" (quote p-form) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :fn) (list (list "fn" (quote :fn)) (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "SET" (list 3 9 6 5 0)))) (om-make-point 153 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "hexachords" 0 (om-make-point 5 45) "" "hexachords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 307 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 1 0 nil 0) (1 0 2 1 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "forten" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 158 57) (om-make-point 23 28) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 94 62) (om-make-point 24 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FAMILLE" (quote famille) (quote ((om-load-inputfun (quote input-funbox) "Zn" "N" 12) (om-load-inputfunmenu1 (quote input-funmenu) "familly" "FAMILLY" "tic" (list (list "tac" "tac") (list "tai" "tai") (list "tic" "tic") (list "ttl" "ttl") (list "tp" "tp") (list "tid" "tid"))) (om-load-inputfun (quote input-funbox) "number of elements" "K" 6) (om-load-inputfun (quote input-funbox) "howmany answers" "HOWMANY" 20))) (om-make-point 79 108) (om-make-point 172 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (4 0 2 0 nil 0) (6 0 2 1 nil 0) (3 0 2 2 nil 0) (4 0 3 0 nil 0) (6 0 4 0 nil 0) (2 0 5 1 nil 0) (7 0 6 0 nil 0) (10 0 7 0 nil 0) (9 0 10 0 nil 0) (8 0 10 2 nil 0))) 7.01 nil "" (om-make-point 1721 109) (om-make-point 1069 943)) (quote nil) (om-make-point 94 60) nil (list (list (list 0 1 3 4 6 9) (list 0 1 2 4 5 8) (list 0 1 2 4 6 8) (list 0 1 2 5 7 8) (list 0 1 2 6 7 8) (list 0 1 2 5 7 8) (list 0 1 4 5 6 8) (list 0 2 3 4 6 8) (list 0 1 4 5 6 8) (list 0 2 3 4 6 8) (list 0 1 2 4 6 8) (list 0 1 2 4 5 8) (list 0 1 2 3 5 7) (list 0 1 2 3 6 7) (list 0 2 3 4 5 7) (list 0 1 2 3 5 7) (list 0 1 2 3 4 6) (list 0 1 2 3 4 5))) nil "I-combinatorial-hex"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 5 1 nil 0) (4 0 5 2 nil 0) (3 0 5 3 nil 0) (2 0 5 4 nil 0) (8 0 7 0 nil 0) (6 0 7 1 nil 0) (10 0 8 0 nil 0) (11 0 10 0 nil 0) (9 0 10 1 nil 0))) nil 7.01))
