; OM File Header - Saved 2023/04/03 14:29:14
; (7.01 :patc (om-make-point 10 10) (om-make-point 251 38) (om-make-point 1199 747) "" 183 0 nil "2023/04/03 14:29:14")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "001-Twine-hex" (quote ((let ((box (om-load-boxcomment "comment 5" (om-make-point 448 60) (quote "A - hexachords used by Lindberg$B - Lindberg's hexachords, their Forte number, and their complements.$C - all hexachords that have inversional combinatoriality") "" (om-make-point 315 627) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 4" (om-make-point 24 30) (quote "C") "" (om-make-point 204 587) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 3" (om-make-point 24 30) (quote "B") "" (om-make-point 237 412) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 24 30) (quote "A") "" (om-make-point 100 29) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 1 199) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "Twine-hex" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE 2" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 59 450) (om-make-point 267 100) (load-buffer-textfile (quote ("((0 1 2 3 4 6) 6-2 (5 7 8 9 10 11))" "((0 1 2 3 6 7) 6-5 (4 5 8 9 10 11))" "((0 1 3 4 6 9) 6-27 (2 5 7 8 10 11))" "((0 1 2 5 7 8) 6-18 (3 4 6 9 10 11))" "((0 2 3 4 6 8) 6-21 (1 5 7 9 10 11))" "((0 1 2 4 6 8) 6-22 (3 5 7 9 10 11))" "" "" "")) (quote textfile) "supersede" "list") "x" nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pcs-fn-comp" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "pcset" nil) (om-load-inputfun (quote input-funbox) "" "fn" nil) (om-load-inputfun (quote input-funbox) "" "compl" nil))) (om-make-point 115 371) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist 3" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 511 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 468 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "compl" 2 (om-make-point 501 46) "" "compl" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 71 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 273 304) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 160 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 325 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 47 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "fn" 1 (om-make-point 277 45) "" "fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pcset" 0 (om-make-point 5 45) "" "pcset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 326 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 226 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (7 0 3 0 nil 0) (5 0 4 0 nil 0) (3 0 5 0 nil 0) (6 0 5 1 nil 0) (1 0 5 2 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (4 1 10 0 nil 0) (4 0 11 0 nil 0))) 1 "pcs-fn-comp" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "ForteN" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "hexachords" nil))) (om-make-point 35 296) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 261 200) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 124 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-FORM" (quote p-form) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :fn) (list (list "fn" (quote :fn)) (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "SET" (list 3 9 6 5 0)))) (om-make-point 153 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "hexachords" 0 (om-make-point 5 45) "" "hexachords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 307 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 1 0 nil 0) (1 0 2 1 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "forten" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "I-combinatorial-hex" (om-load-patch-abs1 "I-combinatorial-hex" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 16 30) (quote "") "" (om-make-point 279 115) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pcs-fn-comp" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "pcset" nil) (om-load-inputfun (quote input-funbox) "" "fn" nil) (om-load-inputfun (quote input-funbox) "" "compl" nil))) (om-make-point 260 450) (om-make-point 220 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist 3" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 511 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 468 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "compl" 2 (om-make-point 501 46) "" "compl" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 71 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 273 304) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 160 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 325 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 47 123) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "fn" 1 (om-make-point 277 45) "" "fn" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "pcset" 0 (om-make-point 5 45) "" "pcset" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 326 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 226 400) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (7 0 3 0 nil 0) (5 0 4 0 nil 0) (3 0 5 0 nil 0) (6 0 5 1 nil 0) (1 0 5 2 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (4 1 10 0 nil 0) (4 0 11 0 nil 0))) 1 "pcs-fn-comp" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "get-complement" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 370 341) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 279 251) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "COMP" (quote comp) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FROM" 3) (om-load-inputfun (quote input-funbox) "" "TO" 13) (om-load-inputfun (quote input-funbox) "" "LIST" (list 0 1 2 7)))) (om-make-point 161 156) (om-make-point 183 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 72 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 385 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 285 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 3 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "get-complement" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "PC-sets" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "hexachords" nil))) (om-make-point 193 341) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "PC-SET" (quote pc-set) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "vector" (quote :vector)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FN-NAME" (quote |6-Z10|)))) (om-make-point 219 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 261 200) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 124 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "hexachords" 0 (om-make-point 5 45) "" "hexachords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 307 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 4 0 nil 0) (1 0 5 0 nil 0))) 1 "pc-sets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 386 582) (om-make-point 261 245) (load-buffer-textfile (quote ("((0 1 3 4 6 9) 6-27 (2 5 7 8 10 11))" "((0 1 2 4 5 8) 6-15 (3 6 7 9 10 11))" "((0 1 2 4 6 8) 6-22 (3 5 7 9 10 11))" "((0 1 2 5 7 8) 6-18 (3 4 6 9 10 11))" "((0 1 2 6 7 8) 6-7 (3 4 5 9 10 11))" "((0 1 2 5 7 8) 6-18 (3 4 6 9 10 11))" "((0 1 4 5 6 8) 6-16 (2 3 7 9 10 11))" "((0 2 3 4 6 8) 6-21 (1 5 7 9 10 11))" "((0 1 4 5 6 8) 6-16 (2 3 7 9 10 11))" "((0 2 3 4 6 8) 6-21 (1 5 7 9 10 11))" "((0 1 2 4 6 8) 6-22 (3 5 7 9 10 11))" "((0 1 2 4 5 8) 6-15 (3 6 7 9 10 11))" "((0 1 2 3 5 7) 6-9 (4 6 8 9 10 11))" "((0 1 2 3 6 7) 6-5 (4 5 8 9 10 11))" "((0 2 3 4 5 7) 6-8 (1 6 8 9 10 11))" "((0 1 2 3 5 7) 6-9 (4 6 8 9 10 11))" "((0 1 2 3 4 6) 6-2 (5 7 8 9 10 11))" "((0 1 2 3 4 5) 6-1 (6 7 8 9 10 11))" "" "" "")) (quote textfile) "supersede" "list") "x" nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-ITER" (quote remove-iter) (quote ((om-load-inputfun (quote input-funbox) "sequence" "SEQUENCE" (list 1 2)))) (om-make-point 243 289) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "ForteN" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "hexachords" nil))) (om-make-point 91 231) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 261 200) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 124 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "P-FORM" (quote p-form) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :fn) (list (list "fn" (quote :fn)) (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "SET" (list 3 9 6 5 0)))) (om-make-point 153 173) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "hexachords" 0 (om-make-point 5 45) "" "hexachords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 307 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 310) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 1 0 nil 0) (1 0 2 1 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "forten" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 158 57) (om-make-point 23 28) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 94 62) (om-make-point 24 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FAMILLE" (quote famille) (quote ((om-load-inputfun (quote input-funbox) "Zn" "N" 12) (om-load-inputfunmenu1 (quote input-funmenu) "familly" "FAMILLY" "tic" (list (list "tac" "tac") (list "tai" "tai") (list "tic" "tic") (list "ttl" "ttl") (list "tp" "tp") (list "tid" "tid"))) (om-load-inputfun (quote input-funbox) "number of elements" "K" 6) (om-load-inputfun (quote input-funbox) "howmany answers" "HOWMANY" 20))) (om-make-point 79 108) (om-make-point 172 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (5 0 1 1 nil 0) (2 0 1 2 nil 0) (3 0 2 0 nil 0) (5 0 3 0 nil 0) (1 0 4 1 nil 0) (6 0 5 0 nil 0) (9 0 6 0 nil 0) (8 0 9 0 nil 0) (7 0 9 2 nil 0))) 7.01 nil "" (om-make-point 1535 75) (om-make-point 1015 977)) (quote nil) (om-make-point 186 598) nil nil nil "I-combinatorial-hex"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 220 45) (quote "All of these hexachords $have inversional combinatoriality.") "" (om-make-point 901 304) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SIXTH" (quote sixth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 823 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIFTH" (quote fifth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 607 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FOURTH" (quote fourth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 805 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 597 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 793 23) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 589 23) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 7" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 728 457) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 2 4 6 8)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 1388 858) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 6" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 725 269) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 2 5 7 8)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 5" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 721 70) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 2 3 6 7)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 4" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 507 457) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 2 3 4 6 8)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 3" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 503 273) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 3 4 6 9)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 2" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 495 73) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 2 3 4 6)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 193 73) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 241 192) (om-make-point 142 128) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 1 2 3 4 6) (list 0 1 2 3 6 7) (list 0 1 3 4 6 9) (list 0 1 2 5 7 8) (list 0 2 3 4 6 8) (list 0 1 2 4 6 8)) :from-file t)) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "get-complement" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 94 192) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 279 251) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "COMP" (quote comp) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :integer) (list (list "integer" (quote :integer)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FROM" 3) (om-load-inputfun (quote input-funbox) "" "TO" 13) (om-load-inputfun (quote input-funbox) "" "LIST" (list 0 1 2 7)))) (om-make-point 161 156) (om-make-point 183 67) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 72 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 385 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 285 354) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 3 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "get-complement" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 13 59) (om-make-point 114 88) (load-buffer-textfile (quote ("(0 1 2 3 4 6)" "(0 1 2 3 6 7)" "(0 1 3 4 6 9)" "(0 1 2 5 7 8)" "(0 2 3 4 6 8)" "(0 1 2 4 6 8)" "" "")) (quote textfile) "supersede" "list") "x" nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((25 1 4 0 nil 0) (6 0 5 1 nil 0) (25 1 6 0 nil 0) (7 0 6 1 nil 0) (24 0 6 2 nil 0) (25 1 7 0 nil 0) (25 1 10 0 nil 0) (25 1 11 0 nil 0) (25 1 12 0 nil 0) (25 1 13 0 nil 0) (25 1 14 0 nil 0) (25 1 15 0 nil 0) (10 0 16 2 nil 0) (12 0 17 2 nil 0) (14 0 18 2 nil 0) (11 0 19 2 nil 0) (13 0 20 2 nil 0) (15 0 21 2 nil 0) (25 1 22 0 nil 0) (25 1 23 2 nil 0) (25 1 24 0 nil 0))) nil 7.01))
