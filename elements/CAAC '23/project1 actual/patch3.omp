; OM File Header - Saved 2023/02/22 19:46:48
; (7.01 :patc (om-make-point 10 60) (om-make-point 120 25) (om-make-point 1280 747) "" 183 0 nil "2023/02/22 19:46:48")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "patch3" (quote ((let ((box (om-load-editor-box1 "MULTI-SEQ 7" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 568 683) (om-make-point 100 70) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8800 6800 7800 6200 6500 7500) (7600 8600 7000 7300 8300) (6200 8200 7200 7500 8500 6800 7100 8100) (7600 8900 6700 7000 8000) (7800 8100 9100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50) (50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50))) :loffset (quote ((0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0))) :lchan (quote ((1 1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6800 6200 6500) (7600 7000 7300) (6200 6900 7200 7500 6800 7100) (7600 6700 7000) (7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 8800 6500 7800 6200 7100 7200 7500) (7300 8600 7000 7900 8000 8300) (5900 7900 7200 8200 8500 6800 7700 7800 8100) (8500 8600 6700 7600 7700 8000) (7800 8700 8800 9100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 6200 7100) (7300 7000 7900) (5900 7800 7200 8100 6800 7700) (8500 6700 7600) (7800 8700))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500 6200) (7300 7000) (5900 6900 7200 6800) (7600 6700) (7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000) (4000 4000 4000 4000) (4000 4000) (4000))) :lvel (quote ((50 50 50) (50 50) (50 50 50 50) (50 50) (50))) :loffset (quote ((0 0 0) (0 0) (0 0 0 0) (0 0) (0))) :lchan (quote ((1 1 1) (1 1) (1 1 1 1) (1 1) (1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0) (0 0 0 0) (0 0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0)) ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0)) ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0)) ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0)) ((0 0 0) (0 0) (0 0 0 0) (0 0) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ 6" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 425 687) (om-make-point 100 70) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500) (6500 6200 7300) (7000 5900) (6900 7200 6800 7600) (6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000) (4000 4000))) :lvel (quote ((50) (50 50 50) (50 50) (50 50 50 50) (50 50))) :loffset (quote ((0) (0 0 0) (0 0) (0 0 0 0) (0 0))) :lchan (quote ((1) (1 1 1) (1 1) (1 1 1 1) (1 1))) :legato 0)))) (load-port-info newobj (quote ((0) (0 0 0) (0 0) (0 0 0 0) (0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600) (6800 6200 6500 7300 7600 8400) (7300 8100 5900 6200 7000) (6900 7200 6800 7100 7600 7900 8700) (6700 7000 7800 8100 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50) (50 50 50 50 50) (50 50 50 50 50 50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8600) (6500 7600 6200 7300 8400) (8100 5900 7000) (6900 7200 8300 6800 7900 7600 8700) (6700 7800 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50 50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1 1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7600 7900 8300) (6300 6600 7000 7300 7400 7700 8100) (7000 7400 7800 5900 6000 6300 6700) (7000 7300 6900 7600 7700 8000 8400) (6800 7100 7500 7800 7900 8200 8600))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50 50) (50 50 50 50 50 50 50) (50 50 50 50 50 50 50) (50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8600) (6500 7600 6200 7300 8400) (8100 5900 7000) (6900 7200 8300 6800 7900 7600 8700) (6700 7800 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50 50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1 1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0) (0 0 0) (0 0) (0 0 0 0) (0 0)) ((0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0)) ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0)) ((0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0)) ((0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0) (0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 880 527) (om-make-point 400 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ 5" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 299 688) (om-make-point 100 70) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200) (7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50) (50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0) (0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1) (1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0) (0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8600 6500 7600 7900) (6200 7300 7600) (8700 8100 8400 5900 7000 7300) (6900 8000 7200 8300 8600) (8200 7600 8700 6700 8100 7800 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50) (50 50 50 50 50 50) (50 50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1) (1 1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6200 6500) (7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100 7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 6600 7400 7600) (6200 6300 7100 7300) (7300 7400 7900 8100 5900 6000 6800 7000) (7000 7800 8000 7200 7300 8100 8300) (6900 8500 6800 7600 7800 7900 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0) (0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0)) ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)) ((0 0 0 0 0) (0 0 0) (0 0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0 0)) ((0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ 4" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 172 686) (om-make-point 100 70) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6800 7800 6500 7500 7300 7600 8400 8600) (7300 8100 5900 6200 7000 7200) (6900 7200 8000 8200) (7200 8500 6800 7100 8100 7600 7900 8700 8900) (7000 8000 7800 8100 8900 9100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500 7600 6200 7300 8400) (8100 5900 7000) (6900 8000) (7200 8300 6800 7900 7600 8700) (6700 7800 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50 50) (50 50 50))) :loffset (quote ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0))) :lchan (quote ((1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1 1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500 6200 7300) (7000 5900) (6900) (7200 6800 7600) (6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000) (4000 4000))) :lvel (quote ((50 50 50 50) (50 50) (50) (50 50 50) (50 50))) :loffset (quote ((0 0 0 0) (0 0) (0) (0 0 0) (0 0))) :lchan (quote ((1 1 1 1) (1 1) (1) (1 1 1) (1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0) (0) (0 0 0) (0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7900 8300 6200 6600 7000 7300 7700 8100) (7000 7400 7800 5900 6300 6700) (6900 7300 7700) (7600 8000 8400) (6700 7100 7500 7800 8200 8600))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500 7600 6200 7300 8400) (8100 5900 7000) (6900 8000) (7200 8300 6800 7900 7600 8700) (6700 7800 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50 50) (50 50 50))) :loffset (quote ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0))) :lchan (quote ((1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1 1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0)) ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0)) ((0 0 0 0) (0 0) (0) (0 0 0) (0 0)) ((0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0 0) (0 0 0 0 0 0)) ((0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0 0) (0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ 3" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 23 685) (om-make-point 100 70) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)) ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)) ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)) ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 1440 692) (om-make-point 399 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIFTH" (quote fifth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 552 613) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FOURTH" (quote fourth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 425 611) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 305 611) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 201 612) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 124 611) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "multiplication-all-partitions" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "row-partitions" nil))) (om-make-point 95 391) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 273 350) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "multiplication" (om-load-patch-abs1 "multiplication" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 375 423) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb-final-unique-pc" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chords" nil) (om-load-inputfun (quote input-funbox) "" "interval-lists" nil))) (om-make-point 181 234) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 356 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 375 216) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "iterate-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-members" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 146 235) (om-make-point 104 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 376 376) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 395 236) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 264 464) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 113 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 205 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 340 62) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-members" 0 (om-make-point 5 45) "" "chord-members" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 316 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 216 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (0 0 2 0 nil 0) (5 0 3 0 nil 0) (7 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (2 1 8 0 nil 0) (2 0 9 0 nil 0))) 1 "iterate-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 175 439) (om-make-point 110 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 274 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-lists" 1 (om-make-point 396 44) "" "interval-lists" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 37 108) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 275 539) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (6 0 2 0 nil 0) (4 0 2 1 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "tn-comb-final-unique-pc" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "partitions->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list-of-midics" nil))) (om-make-point 279 330) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 503 167) (om-make-point 34 30) (list 50) "(50)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 413 167) (om-make-point 58 30) (list 4000) "(4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 331 164) (om-make-point 69 30) (list 0 4000) "(0 4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 386 433) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 198 210) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list-of-midics" 0 (om-make-point 5 45) "" "grouped-list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 433 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 333 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (2 0 5 2 nil 0) (1 0 5 3 nil 0) (0 0 5 4 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "partitions->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 115 107) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 380 305) (om-make-point 37 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 137 233) (om-make-point 33 39) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 101 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 40 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 182 392) (om-make-point 141 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 513) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 328 143) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 269 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 274 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 340 626) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 158 614) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 4 0 nil 0) (8 0 4 1 nil 0) (0 0 4 2 nil 0) (4 0 5 0 nil 0) (10 0 7 0 nil 0) (6 0 7 1 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0) (5 1 11 0 nil 0) (5 0 12 0 nil 0))) 1 "return-internal-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq" 0 (om-make-point 5 45) "" "chord-seq" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 1 0 nil 0) (3 0 1 1 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "chord-seq" nil))) (om-make-point 145 215) nil (list (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))) nil "multiplication"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 99 126) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "row-partitions" 0 (om-make-point 5 44) "" "row-partitions" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 313 457) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 213 457) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (0 1 4 0 nil 0) (0 0 5 0 nil 0))) 1 "multiplication-all-partitions" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 45 80) (om-make-point 184 89) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000 7400 6600 6800 7100 7000 7300 6500 6900 6700 6400 7500)) :ldur (quote (1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100 100 100 100 100 100 100 100)) :loffset (quote (0 0 0 0 0 0 0 0 0 0 0 0)) :lchan (quote (1 1 1 1 1 1 1 1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0 0 0 0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) "x" nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 3 (om-make-point 967 279) (om-make-point 681 25) 0 0 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "all-rotations" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "original-list" nil))) (om-make-point 318 110) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 381 494) (om-make-point 83 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 207 393) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 301 310) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 342 93) (om-make-point 34 35) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 300 139) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 248 83) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 335 204) (om-make-point 89 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "original-list" 0 (om-make-point 5 45) "" "original-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 446 593) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 346 593) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (7 0 1 0 nil 0) (2 0 1 1 nil 0) (6 0 2 0 nil 0) (5 0 4 0 nil 0) (3 0 4 1 nil 0) (7 0 5 0 nil 0) (4 0 6 1 nil 0) (0 1 8 0 nil 0) (0 0 9 0 nil 0))) 1 "all-rotations" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 320 64) (om-make-point 80 30) (list 4 3 2 1 2) "(4 3 2 1 2)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "row-partitions" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list-of-midics" nil) (om-load-inputfun (quote input-funbox) "" "rotations" nil))) (om-make-point 214 264) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 251 347) (om-make-point 111 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GROUP-LIST" (quote group-list) (quote ((om-load-inputfun (quote input-funbox) "list to group" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "list of group lengths" "SEGMENTATION" (list 1 3)) (om-load-inputfunmenu1 (quote input-funmenu) "normal or circular" "MODE" (quote linear) (list (list "linear" (quote (quote linear))) (list "circular" (quote (quote circular))))))) (om-make-point 162 243) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 420 158) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "rotations" 1 (om-make-point 461 49) "" "rotations" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list-of-midics" 0 (om-make-point 5 45) "" "list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 421 456) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 207 462) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "row-partitions" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 541 74) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "multiplication" (om-load-patch-abs1 "multiplication" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 375 423) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb-final-unique-pc" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chords" nil) (om-load-inputfun (quote input-funbox) "" "interval-lists" nil))) (om-make-point 181 234) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 356 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 375 216) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "iterate-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-members" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 146 235) (om-make-point 104 59) nil nil (list (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 376 376) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "same-pc?" (om-load-patch-abs1 "same-pc?" (quote ((let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 177 96) (om-make-point 38 30) 1200 "1200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 228 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic2" 1 (om-make-point 285 43) "" "midic2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "midic1" 0 (om-make-point 5 45) "" "midic1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM// 2" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 373 134) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 148 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 0 nil 0) (6 1 2 0 nil 0) (5 1 2 1 nil 0) (3 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 6 0 nil 0) (0 0 6 1 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "midic1" nil) (om-load-inputfun (quote input-funbox) "" "midic2" nil))) (om-make-point 395 236) (om-make-point 143 67) (list nil) "l" "same-pc?"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 264 464) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 260 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 113 118) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Tn-comb 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "chord-notes" nil) (om-load-inputfun (quote input-funbox) "" "intervals" nil))) (om-make-point 205 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 168 169) (om-make-point 42 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 235 237) (om-make-point 86 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 240 109) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 85 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-notes" 0 (om-make-point 5 45) "" "chord-notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 356 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 162 328) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "tn-comb" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "intervals" 1 (om-make-point 340 62) "" "intervals" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-members" 0 (om-make-point 5 45) "" "chord-members" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 316 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 216 562) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (1 0 0 1 nil 0) (0 0 2 0 nil 0) (5 0 3 0 nil 0) (7 0 4 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (2 1 8 0 nil 0) (2 0 9 0 nil 0))) 1 "iterate-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 175 439) (om-make-point 110 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 274 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "interval-lists" 1 (om-make-point 396 44) "" "interval-lists" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chords" 0 (om-make-point 37 108) "" "chords" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 275 539) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 139 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (6 0 2 0 nil 0) (4 0 2 1 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "tn-comb-final-unique-pc" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "partitions->chord-seq" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list-of-midics" nil))) (om-make-point 279 330) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 503 167) (om-make-point 34 30) (list 50) "(50)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 413 167) (om-make-point 58 30) (list 4000) "(4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 331 164) (om-make-point 69 30) (list 0 4000) "(0 4000)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 386 433) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 180 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 50)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 198 210) (om-make-point 376 83) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200) (7300 7000 5900) (6900 7200) (6800 7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000))) :lvel (quote ((50 50) (50) (50 50 50) (50 50) (50 50 50 50))) :loffset (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0))) :lchan (quote ((1 1) (1) (1 1 1) (1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0) (0 0 0) (0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list-of-midics" 0 (om-make-point 5 45) "" "grouped-list-of-midics" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 433 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 333 537) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (2 0 5 2 nil 0) (1 0 5 3 nil 0) (0 0 5 4 nil 0) (3 1 7 0 nil 0) (3 0 8 0 nil 0))) 1 "partitions->chord-seq" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "return-internal-intervals" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "grouped-list" nil))) (om-make-point 115 107) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 380 305) (om-make-point 37 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 137 233) (om-make-point 33 39) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 101 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 40 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 182 392) (om-make-point 141 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 252 513) (om-make-point 90 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 328 143) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputkeyword (quote input-keyword) "test function" "test" (quote :test) (quote (quote <)) nil))) (om-make-point 269 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 274 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "grouped-list" 0 (om-make-point 5 45) "" "grouped-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 90 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 340 626) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 158 614) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 3 0 nil 0) (2 0 4 0 nil 0) (8 0 4 1 nil 0) (0 0 4 2 nil 0) (4 0 5 0 nil 0) (10 0 7 0 nil 0) (6 0 7 1 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0) (5 1 11 0 nil 0) (5 0 12 0 nil 0))) 1 "return-internal-intervals" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq" 0 (om-make-point 5 45) "" "chord-seq" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (4 0 1 0 nil 0) (3 0 1 1 nil 0) (1 0 2 0 nil 0) (4 0 3 0 nil 0))) 7.01 nil "" (om-make-point 200 200) (om-make-point 658 516)) (quote ((om-load-inputfun (quote input-funbox) "" "chord-seq" nil))) (om-make-point 618 193) nil (list (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))) nil "multiplication"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 755 281) (om-make-point 287 209) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8500 6500 7500) (6200 7200 7300 7000 8000 5900 6900) (6900 7900 7200 8200) (6800 7800) (8600 6700 7700 7800 8800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50) (50 50 50 50 50 50 50) (50 50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 8600 6500 6800 7600 7900) (6500 7600 8700 8100 8400 5900 6200 7000 7300) (6900 8000 7200 7500 8300 8600) (6800 7100 7900 8200) (7600 8700 6700 7000 7800 8100 8900 9200))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50 50 50) (50 50 50 50 50 50 50 50 50) (50 50 50 50 50 50) (50 50 50 50) (50 50 50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1 1 1) (1 1 1 1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 7800 6500 6800) (6500 7600 7000 7300 5900 6200) (6900 7200 7500) (6800 7100) (7600 6700 7000 7800 8100))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000) (4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50) (50 50 50 50 50 50) (50 50 50) (50 50) (50 50 50 50 50))) :loffset (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1 1 1) (1 1 1) (1 1) (1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 6500) (6200 7300 7000 5900) (6900 7200) (6800) (7600 6700 7800))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000) (4000 4000 4000 4000) (4000 4000) (4000) (4000 4000 4000))) :lvel (quote ((50 50) (50 50 50 50) (50 50) (50) (50 50 50))) :loffset (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0))) :lchan (quote ((1 1) (1 1 1 1) (1 1) (1) (1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7500 8400 6500 7400 7600) (6200 7300 8400 7900 8100 5900 6800 7000) (7800 8000 7200 8100 8300) (6800 7700 7900) (8500 6700 7600 7800 8700 8900))) :lonset (quote (0 4000 8000 12000 16000 20000)) :ldur (quote ((4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000 4000 4000 4000) (4000 4000 4000 4000 4000) (4000 4000 4000) (4000 4000 4000 4000 4000 4000))) :lvel (quote ((50 50 50 50 50) (50 50 50 50 50 50 50 50) (50 50 50 50 50) (50 50 50) (50 50 50 50 50 50))) :loffset (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1 1) (1 1 1 1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0 0 0) (0 0 0 0 0 0 0) (0 0 0 0) (0 0) (0 0 0 0 0)) ((0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0) (0 0 0 0 0 0 0 0)) ((0 0 0 0) (0 0 0 0 0 0) (0 0 0) (0 0) (0 0 0 0 0)) ((0 0) (0 0 0 0) (0 0) (0) (0 0 0)) ((0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0) (0 0 0) (0 0 0 0 0 0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.01 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (list (quote g) (quote g) (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 1067 583) (om-make-point 181 25) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 1 nil 0) (6 0 1 1 nil 0) (7 0 2 1 nil 0) (8 0 3 1 nil 0) (9 0 4 1 nil 0) (10 0 5 0 nil 0) (10 0 6 0 nil 0) (10 0 7 0 nil 0) (10 0 8 0 nil 0) (10 0 9 0 nil 0) (14 0 10 0 nil 0) (13 0 12 0 nil 0) (11 1 14 0 nil 0) (12 0 14 1 nil 0) (15 1 16 0 nil 0) (16 0 17 1 nil 0))) nil 7.01))