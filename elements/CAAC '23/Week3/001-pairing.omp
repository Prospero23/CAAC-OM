; OM File Header - Saved 2023/02/06 12:43:06
; (7.01 :patc (om-make-point 118 60) (om-make-point 1907 87) (om-make-point 1077 619) "" 183 0 nil nil)
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "001-pairing" (quote ((let ((box (om-load-boxcall (quote abstraction) "find-all-pairs" (om-load-patch-abs1 "find-all-pairs" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 261 302) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "all-pairs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "find-all-pairs" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 138 169) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 284 416) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pairing" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "nth-elem" nil) (om-load-inputfun (quote input-funbox) "" "cdr-of-list" nil))) (om-make-point 231 351) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 268 270) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 128 236) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 232 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "cdr-of-list" 1 (om-make-point 260 52) "" "cdr-of-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "nth-elem" 0 (om-make-point 5 45) "" "nth-elem" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 382 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 282 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "pairing" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "onlist" (quote onlistloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 285 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 123 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 217 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 62 155) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 444 546) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 124 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 4 0 nil 0) (6 0 5 0 nil 0) (0 1 7 0 nil 0) (0 0 8 0 nil 0))) 1 "find-all-pairs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 228 205) (om-make-point 40 23) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 202 248) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (4 0 1 0 nil 0) (1 0 3 0 nil 0) (2 0 3 1 nil 0))) 7.01 nil "" (om-make-point 1809 77) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 679 234) nil (list (list (list (quote a) (quote b)) (list (quote a) (quote c)) (list (quote a) (quote d)) (list (quote a) (quote e)) (list (quote a) (quote f)) (list (quote a) (quote g)) (list (quote b) (quote c)) (list (quote b) (quote d)) (list (quote b) (quote e)) (list (quote b) (quote f)) (list (quote b) (quote g)) (list (quote c) (quote d)) (list (quote c) (quote e)) (list (quote c) (quote f)) (list (quote c) (quote g)) (list (quote d) (quote e)) (list (quote d) (quote f)) (list (quote d) (quote g)) (list (quote e) (quote f)) (list (quote e) (quote g)) (list (quote f) (quote g)))) nil "find-all-pairs"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 560 272) (om-make-point 40 23) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil) (om-load-inputfun (quote input-funbox) "level of parenthesis" "LEVEL" nil))) (om-make-point 534 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "find-all-pairs" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 470 236) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 284 416) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pairing" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "nth-elem" nil) (om-load-inputfun (quote input-funbox) "" "cdr-of-list" nil))) (om-make-point 231 351) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 268 270) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 128 236) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 232 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "cdr-of-list" 1 (om-make-point 260 52) "" "cdr-of-list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "nth-elem" 0 (om-make-point 5 45) "" "nth-elem" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 382 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 282 379) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "pairing" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "onlist" (quote onlistloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 285 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 123 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 217 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 62 155) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 444 546) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 124 543) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (2 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 3 0 nil 0) (6 0 4 0 nil 0) (6 0 5 0 nil 0) (0 1 7 0 nil 0) (0 0 8 0 nil 0))) 1 "find-all-pairs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 303 60) (quote "butlast: removes last element list.$cdr: removes first element from list.$onlist: returns the cdr of the list in an iteration.") "" (om-make-point 418 86) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "what-is-onlist-loop?" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 262 188) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 117 202) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "onlist" (quote onlistloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 37 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 5 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 182 334) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 58 341) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (0 1 3 0 nil 0) (0 0 4 0 nil 0))) 1 "what-is-onlist-loop?" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "find-cons-pairs" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 109 235) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 246 381) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 110 359) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 245 204) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 203 145) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 76 145) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 45 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 6 45) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 297 487) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 197 487) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (5 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (6 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 0 nil 0) (0 1 7 0 nil 0) (0 0 8 0 nil 0))) 1 "find-cons-pairs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 130 99) (om-make-point 87 30) (list (quote a) (quote b) (quote c) (quote d) (quote e) (quote f) (quote g)) "(a b c d e f g)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (7 0 3 0 nil 0) (7 0 5 0 nil 0) (7 0 6 0 nil 0))) nil 7.01))
